/**
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate 
(polygonal) numbers and are generated by the following formulae:

Triangle:   P_{3,n}=n(n+1)/2     -> 1, 3, 6, 10, 15, ...
Square:     P_{4,n}=n^2          -> 1, 4, 9, 16, 25, ...
Pentagonal: P_{5,n}=n(3n-1)/2    -> 1, 5, 12, 22, 35, ...
Hexagonal:  P_{6,n}=n(2n-1)      -> 1, 6, 15, 28, 45, ...
Heptagonal: P_{7,n}=n(5n-3)/2    -> 1, 7, 18, 34, 55, ...
Octagonal:  P_{8,n}=n(3n-2)      -> 1, 8, 21, 40, 65, ... 

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
The set is cyclic, in that the last two digits of each number is the first two digits of the 
next number (including the last number with the first).
Each polygonal type: triangle (P_{3,127}=8128), square (P_{4,91}=8281), and pentagonal 
(P_{5,44}=2882), is represented by a different number in the set.
This is the only set of 4-digit numbers with this property.
Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal 
type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a 
different number in the set.
 
solution:
2512, 1281, 8128, 2882, 8256, 5625, sum: 28684

real    0m0.234s
user    0m0.000s
sys     0m0.092s
*/

#include <stdio.h>
#include <math.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define f2d(n) ((n)/100)
#define l2d(n) ((n)%100)

typedef struct {
    int f2d;
    int l2d;
    int num;
} NUM;

typedef struct {
    int cnt;
    int start;
    NUM *set;
    int (*f)(int n);
} SET;


// An iterative binary search function.
// search input arr[] based on "f2d" field
// input arr[] can have multiple elements with similar f2d. the function will return the position
// of theh first element in the array
int binSearch(NUM arr[], int low, int high, int x) {
    while (low <= high) {
        int mid = low + (high - low) / 2;

        // Check if x is present at mid
        if (arr[mid].f2d == x) {
            // find first location of searched value
            while (mid >= 0 && arr[mid].f2d == x)
                mid--;
            return mid+1;
        }

        // If x greater, ignore left half
        if (arr[mid].f2d < x)
            low = mid + 1;

        // If x is smaller, ignore right half
        else
            high = mid - 1;
    }

    // If we reach here, then element was not present
    return -1;
}

/*
    return factorial value of n
*/
int factorial(const int n)
{
    int f = 1;
    for (int i=1; i<=n; ++i)
        f *= i;
    return f;
}

/*
    arr[] -> imput array
    n -> size of input array
    n_arr[] -> address array of pointers to set of numbers of size n

    return number of elemets in n_arr[];
    -1 if error
*/
int gcomb (SET arr[], int n, SET **n_arr[]) {
    int i, j, k, l, m, q, e;
    int rn = factorial(n);

    // allocate result list of arrays
    if ((*n_arr = malloc(rn*sizeof(SET *))) == NULL) {
        fprintf(stderr, "Failed to allocate memory: %s\n", strerror(errno));
        return -1;
    }

    for (i = 0; i < rn; i++) {
        if (((*n_arr)[i] = malloc(n*sizeof(SET))) == NULL) {
            fprintf(stderr, "Failed to allocate memory: %s\n", strerror(errno));
            return -1;
        }
    }

    if (rn == 2) {
        (*n_arr)[0][0] = arr[0];
        (*n_arr)[0][1] = arr[1];
        (*n_arr)[1][0] = arr[1];
        (*n_arr)[1][1] = arr[0];
    }
    else {
        SET e = arr[n-1];   // last element in input array
        SET **tarr;
        k = gcomb(arr, n-1, &tarr);

        m = 0;

        for (j = 0; j < k; j++) {
            for (q = 0; q < n; q++) {
                for (i = 0; i < n-1;) {
                    for (l = 0; l < n; l++) {
                        if (l == q)
                            (*n_arr)[m][l] = e;
                        else {
                            (*n_arr)[m][l] = tarr[j][i];
                            i++;
                        }
                    }
                    m++;
                }
            }
        }

        free(tarr);
    }

    return rn;
}

int Triangle (int n) {
    return ((n)*((n)+1)/2);
}

int Square (int n) {
    int i = pow((n),2);
    return i;
}

int Pentagonal (int n) {
    return ((n)*(3*(n)-1)/2);
}

int Hexagonal (int n) {
    return ((n)*(2*(n)-1));
}

int Heptagonal (int n) {
    return ((n)*(5*(n)-3)/2);
}

int Octagonal (int n) {
    return ((n)*(3*(n)-2));
}

int main () {
    SET sets[6] = {
        {96, 45, NULL, Triangle},
        {68, 32, NULL, Square},
        {56, 26, NULL, Pentagonal},
        {48, 23, NULL, Hexagonal},
        {43, 21, NULL, Heptagonal},
        {40, 19, NULL, Octagonal}
    };

    int n, i, j, s;
    int i0, i1, i2, i3, i4, i5;
    bool found;
    SET **comb_s;

    // initialize all data structures including 4 digits number sets
    for (i = 0; i < 6; i++) {
        if ((sets[i].set = malloc((sets[i].cnt)*sizeof(NUM))) == NULL) {
            fprintf(stderr, "Failed to allocate RAM: %s\n", strerror(errno));
            return 1;
        }

        // fill sets.set
        n = sets[i].start;
        for (j = 0; j < sets[i].cnt; j++, n++) {
            sets[i].set[j].num = sets[i].f(n);
            sets[i].set[j].f2d = f2d(sets[i].set[j].num);
            sets[i].set[j].l2d = l2d(sets[i].set[j].num);
        }
    }

    // generate sets combinations
    if ((s = gcomb(sets, 6, &comb_s)) < 0) {
        fprintf(stderr, "Failed to generate set combinations%s\n");
        for (i = 0; i < 6; i++)
            free(sets[i].set);    
        return 2;
    }

    found = false;
    n = 0;
    // go through combinations of sets until we find cyclic combination
    while (n < s && !found) {
        i0 = 0;
        while (i0 < comb_s[n][0].cnt && !found) {
            i1 = binSearch(comb_s[n][1].set, 0, comb_s[n][1].cnt, comb_s[n][0].set[i0].l2d);
            if (i1 > -1) {
                while (comb_s[n][1].set[i1].f2d == comb_s[n][0].set[i0].l2d && !found) {
                    i2 = binSearch(comb_s[n][2].set, 0, comb_s[n][2].cnt, comb_s[n][1].set[i1].l2d);
                    if (i2 > -1) {
                        while (comb_s[n][2].set[i2].f2d == comb_s[n][1].set[i1].l2d && !found) {
                            i3 = binSearch(comb_s[n][3].set, 0, comb_s[n][3].cnt, comb_s[n][2].set[i2].l2d);
                            if (i3 > -1) {
                                while (comb_s[n][3].set[i3].f2d == comb_s[n][2].set[i2].l2d && !found) {
                                    i4 = binSearch(comb_s[n][4].set, 0, comb_s[n][4].cnt, comb_s[n][3].set[i3].l2d);
                                    if (i4 > -1) {
                                        while (comb_s[n][4].set[i4].f2d == comb_s[n][3].set[i3].l2d && !found) {
                                            i5 = binSearch(comb_s[n][5].set, 0, comb_s[n][5].cnt, comb_s[n][4].set[i4].l2d);
                                            if (i5 > -1) {
                                                while (comb_s[n][5].set[i5].f2d == comb_s[n][4].set[i4].l2d && !found) {
                                                    if (comb_s[n][5].set[i5].l2d == comb_s[n][0].set[i0].f2d)
                                                        // if we got here we found the cyclic combination. exit all loops
                                                        found = true;
                                                    if (!found) i5++;                                               
                                                }
                                            }
                                            if (!found) i4++;
                                        }      
                                    }
                                    if (!found) i3++;    
                                }                        
                            }
                            if (!found) i2++;   
                        }                           
                    }
                    if (!found) i1++;      
                }        
            }
            if (!found) i0++;    
        }
        if (!found) n++;
    }

    if (found) {
        int sum = comb_s[n][0].set[i0].num + comb_s[n][1].set[i1].num +\
            comb_s[n][2].set[i2].num + comb_s[n][3].set[i3].num +\
            comb_s[n][4].set[i4].num + comb_s[n][5].set[i5].num;
        printf("found\n");
        printf("%d, %d, %d, %d, %d, %d, sum: %d\n", \
            comb_s[n][0].set[i0].num, comb_s[n][1].set[i1].num,\
            comb_s[n][2].set[i2].num, comb_s[n][3].set[i3].num,\
            comb_s[n][4].set[i4].num, comb_s[n][5].set[i5].num, sum);
    }

    for (i = 0; i < 6; i++)
        free(sets[i].set);
    free(comb_s);     
    return 0;

}